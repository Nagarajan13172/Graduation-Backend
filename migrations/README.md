# Database Migrations

This directory contains SQL migration scripts for the BillDesk payment integration.

## Migration Files

1. **001_create_pending_orders.sql** - Creates the `pending_orders` table to store payment orders before completion
2. **002_add_payment_fields_to_students.sql** - Adds payment tracking fields to the `students` table

## Running Migrations

### Option 1: Run All Migrations (Recommended)

```bash
cd /home/allyhari/periyar/Graduation-Backend
sqlite3 graduation.db < migrations/run_all.sql
```

### Option 2: Run Individual Migrations

```bash
# Run migration 001
sqlite3 graduation.db < migrations/001_create_pending_orders.sql

# Run migration 002
sqlite3 graduation.db < migrations/002_add_payment_fields_to_students.sql
```

### Option 3: Interactive SQLite

```bash
sqlite3 graduation.db
```

Then in SQLite prompt:
```sql
.read migrations/001_create_pending_orders.sql
.read migrations/002_add_payment_fields_to_students.sql
.exit
```

## Verifying Migrations

After running migrations, verify the changes:

```bash
sqlite3 graduation.db
```

```sql
-- Check if pending_orders table exists
.tables

-- View pending_orders schema
.schema pending_orders

-- View students table schema (check for new payment fields)
.schema students

-- Check indexes
.indexes pending_orders
.indexes students

.exit
```

## Rollback (if needed)

If you need to rollback the migrations:

```sql
-- Remove pending_orders table
DROP TABLE IF EXISTS pending_orders;

-- Remove payment fields from students (SQLite doesn't support DROP COLUMN easily)
-- You'll need to recreate the table without these columns
-- Backup first!
```

## Database Schema

### pending_orders Table

```sql
CREATE TABLE pending_orders (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  orderid TEXT UNIQUE NOT NULL,
  bdorderid TEXT,
  form_data TEXT NOT NULL,
  file_paths TEXT,
  payment_status TEXT DEFAULT 'pending',
  transaction_id TEXT,
  auth_status TEXT,
  amount TEXT DEFAULT '500.00',
  payment_method_type TEXT,
  transaction_date DATETIME,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);
```

**Purpose:** Store incomplete registrations while payment is being processed.

**Fields:**
- `orderid` - Unique order ID generated by backend
- `bdorderid` - BillDesk order ID returned from API
- `form_data` - JSON string containing all registration form fields
- `file_paths` - JSON string containing paths to uploaded files
- `payment_status` - Status: pending, success, failed, expired
- `transaction_id` - BillDesk transaction ID after payment
- `auth_status` - BillDesk auth status code (0300=success, 0399=failed)
- `amount` - Payment amount
- `payment_method_type` - Payment method (netbanking, card, upi, etc.)

### students Table (New Fields)

```sql
ALTER TABLE students ADD COLUMN payment_status TEXT DEFAULT 'pending';
ALTER TABLE students ADD COLUMN orderid TEXT;
ALTER TABLE students ADD COLUMN bdorderid TEXT;
ALTER TABLE students ADD COLUMN transaction_id TEXT;
ALTER TABLE students ADD COLUMN payment_amount TEXT;
ALTER TABLE students ADD COLUMN payment_date DATETIME;
ALTER TABLE students ADD COLUMN payment_method_type TEXT;
```

**Purpose:** Track payment details for completed registrations.

## Migration Flow

1. User submits registration form
2. Backend creates entry in `pending_orders` with form data
3. Backend creates BillDesk order and returns payment URL
4. User completes payment on BillDesk
5. BillDesk calls webhook with payment result
6. Backend updates `pending_orders` with payment status
7. If payment successful, backend creates entry in `students` table
8. Backend copies payment details to `students` record

## Cleanup Jobs

Consider adding a cron job to clean up expired orders:

```sql
-- Delete pending orders older than 24 hours that are still pending
DELETE FROM pending_orders 
WHERE payment_status = 'pending' 
  AND created_at < datetime('now', '-24 hours');
```

## Notes

- SQLite doesn't support all ALTER TABLE operations. If you need to remove columns, you'll need to recreate the table.
- Always backup your database before running migrations.
- Test migrations on a copy of the database first.
